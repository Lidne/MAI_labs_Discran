\section{Описание}
Основная идея алгоритма решения задачи состоит в применении алгоритма Z-блоков на строке, состоящей из образца поиска и строки, по которой проводится поиск. 
Образец и строка склеены символом, который нигде не встречается, чтобы искать только полное вхождение подстроки.

\pagebreak

\section{Исходный код}
\begin{lstlisting}[language=C]
    #include <bits/stdc++.h>
    using namespace std;
    
    int main() {
        string text;
        string pattern;
    
        getline(cin, text);
        getline(cin, pattern);
    
        string sample = pattern + "$" + text;
        int n = sample.size();
        int m = pattern.size();
    
        vector<int> z(n, 0);
    
        int l = 0, r = 0;
    
        for (int i = 1; i < n; i++) {
            if (i <= r) {
                z[i] = min(r - i + 1, z[i - l]);
            }
    
            while (i + z[i] < n && sample[z[i]] == sample[i + z[i]]) {
                ++z[i];
            }
    
            if (i + z[i] - 1 > r) {
                l = i;
                r = i + z[i] - 1;
            }
        }
    
        for (int i = 0; i < n; ++i) {
            if (z[i] >= m) {
                int realPos = i - (m + 1);
    
                cout << realPos << "\n";
            }
        }
        return 0;
    }    

\end{lstlisting}

\pagebreak

\section{Консоль}
\begin{alltt}
[george@GEORGE-HONOR14 src]$ make main
g++ -O2 -std=c++20 -Wall -Wextra -o main main.cpp
[george@GEORGE-HONOR14 src]$ ./main
asdfhgasnnfnf
as
0
6
\end{alltt}
\pagebreak

